#include "test-gc.h"
#include "list.h"
#include "memory.h"

List* initMemory()
{
	List *list = initList();
	Block *block = malloc(sizeof(Block));

	if (block == NULL)
	{
		fprintf(stderr, "malloc Error");
		exit(EXIT_FAILURE);	
	}

	block->first_word = malloc(WORD_NUMBER * WORD_SIZE);
	block->size = WORD_NUMBER;
	block->used = FALSE;
	block->reference = NULL;

	if (block->first_word == NULL)
	{
		fprintf(stderr, "malloc Error");
		exit(EXIT_FAILURE);	
	}

	addListHead(list, (void *)block);

	return list;
}

void* memoryAllocation(List *blocks, size_t size)
{
	Element *current_element = NULL;
	Block *new_block = NULL;
	size_t words_nb = ceil(size / (double)WORD_SIZE);

	if (blocks == NULL)
	{
		fprintf(stderr, "memoryAllocation Error : Illegal argument");
		exit(EXIT_FAILURE);
	}
	else if (blocks->first == NULL)
	{
		fprintf(stderr, "memoryAllocation Error : No available memory");
		exit(EXIT_FAILURE);
	}

	current_element = blocks->first;
	if (((Block*)current_element->value)->size > words_nb && !((Block*)current_element->value)->used)
	{
		new_block = malloc(sizeof(Block));
		if (new_block == NULL)
		{
			fprintf(stderr, "memoryAllocation Error : malloc Error");
			exit(EXIT_FAILURE);
		}
		new_block->first_word = ((Block*)current_element->value)->first_word;
		new_block->size = words_nb;
		new_block->used = TRUE;
		new_block->reference = NULL;

		((Block*)current_element->value)->first_word = new_block->first_word + new_block->size;
		((Block*)current_element->value)->size = ((Block*)current_element->value)->size - new_block->size;

		addListHead(blocks, new_block);

		return new_block->first_word;
	}
	else if (((Block*)current_element->value)->size == words_nb && !((Block*)current_element->value)->used)
	{
		((Block*)current_element->value)->used = TRUE;
		return ((Block*)current_element->value)->first_word;
	}

	while (current_element->next != NULL && (((Block*)current_element->next->value)->size < words_nb || ((Block*)current_element->next->value)->used))
	{
		current_element = current_element->next;
	}

	if (current_element->next == NULL)	// Aucun bloc ne contient assez de mémoire contiguë pour "l'allocation" de mémoire
	{
		fprintf(stderr, "memoryAllocation Error : Too much memory already used");
		return NULL;
	}

	if (((Block*)current_element->next->value)->size > words_nb)
	{
		new_block = malloc(sizeof(Block));
		if (new_block == NULL)
		{
			fprintf(stderr, "memoryAllocation Error : malloc Error");
			exit(EXIT_FAILURE);
		}
		new_block->first_word = ((Block*)current_element->next->value)->first_word;
		new_block->size = words_nb;
		new_block->used = TRUE;
		new_block->reference = NULL;

		((Block*)current_element->next->value)->first_word = new_block->first_word + new_block->size;
		((Block*)current_element->next->value)->size = ((Block*)current_element->next->value)->size - new_block->size;

		addListAfter(blocks, new_block, current_element);

		return new_block->first_word;
	}
	else if (((Block*)current_element->next->value)->size == words_nb)
	{
		((Block*)current_element->next->value)->used = TRUE;
		return ((Block*)current_element->next->value)->first_word;
	}

	return NULL;
}

void memoryFreeing(List *blocks, void *address)
{
	Element *current_element = NULL;
	
	if (blocks == NULL)
	{
		fprintf(stderr, "memoryFreeing Error : Illegal argument");
		exit(EXIT_FAILURE);
	}
	else if (blocks->first == NULL)
	{
		fprintf(stderr, "memoryFreeing Error : No available memory");
		exit(EXIT_FAILURE);
	}

	current_element = blocks->first;
	if (((Block*)current_element->value)->first_word == address)
	{
		if (!((Block*)current_element->value)->used)
		{
			fprintf(stderr, "memoryFreeing Error : This block has already been freed or has never been allocated");
			return;
		}
		((Block*)current_element->value)->used = FALSE;
		if (current_element->next != NULL && !((Block*)current_element->next->value)->used)
		{
			((Block*)current_element->value)->size += ((Block*)current_element->next->value)->size;
			free(current_element->next->value);
			freeListElement(blocks, current_element->next);
		}
		return;
	}

	while (current_element->next != NULL && ((Block*)current_element->next->value)->first_word == address)
	{
		current_element = current_element->next;
	}

	if (current_element->next == NULL)
	{
		fprintf(stderr, "memoryFreeing Error : No block matches the address");
		return;
	}

	if (!((Block*)current_element->next->value)->used)
	{
		fprintf(stderr, "memoryFreeing Error : This block has already been freed or has never been allocated");
		return;
	}
	((Block*)current_element->next->value)->used = FALSE;
	if (current_element->next->next != NULL && !((Block*)current_element->next->next->value)->used)
	{
		((Block*)current_element->next->value)->size += ((Block*)current_element->next->next->value)->size;
		free(current_element->next->next->value);
		freeListElement(blocks, current_element->next->next);
	}
	if (!((Block*)current_element->value)->used)
	{
		((Block*)current_element->next->value)->size += ((Block*)current_element->value)->size;
		free(current_element->value);
		freeListElement(blocks, current_element);
	}
	return;
}

void memoryFreeingAll(List *blocks)
{
	Element *current_element = NULL;

	free(((Block*)blocks->first->value)->first_word);
	current_element = blocks->first;

	while(current_element != NULL)
	{
		free(current_element->value);
		current_element = current_element->next;
	}

	freeListAll(blocks);
}

void blocksAssociation(List *blocks, void *src, void *dest)
{
	Element *current_element = NULL;
	Element *current_element2 = NULL;
	
	if (blocks == NULL)
	{
		fprintf(stderr, "memoryFreeing Error : Illegal argument");
		exit(EXIT_FAILURE);
	}

	current_element = blocks->first;
	current_element2 = blocks->first;

	while (current_element != NULL)
	{
		if (((Block*)current_element->value)->first_word == src)
		{
			if (((Block*)current_element->value)->size != 1)
			{
				fprintf(stderr, "blocksAssociation Error : Invalid size");
				return;
			}
			while (current_element2 != NULL)
			{
				if (((Block*)current_element2->value)->first_word == dest)
				{
					((Block*)current_element->value)->reference = ((Block*)current_element2->value)->first_word;
					return;
				}
				current_element2 = current_element2->next; 
			}
			fprintf(stderr, "blocksAssociation Error : An address is invalid");
			return;
		}
		current_element = current_element->next; 
	}
	fprintf(stderr, "blocksAssociation Error : An address is invalid");
	return;
}

List *initMemoryRandomly()
{
	int i = 0;
	List *blocks = initMemory();
	void *addressTab[10];

	srand(time(NULL));		// Initialisation de rand

	addressTab[i] = memoryAllocation(blocks, 1);	//	Le bloc source de la référence
	for (i = 1; i < 10; i++)
	{
		addressTab[i] = memoryAllocation(blocks, rand()%8 + 1);
	}

	blocksAssociation(blocks, addressTab[0], addressTab[rand()%8 + 2]);
	memoryFreeing(blocks, addressTab[1]);

	return blocks;
}

void displayMemory(List *blocks)
{
	Element *current_element = NULL;
	int number = 0;

	printf("~~~ MEMORY USAGE DEBUG - WORDS NUMBER : %d - WORD SIZE : %d Byte(s) ~~~\n\n", WORD_NUMBER, WORD_SIZE);
	printf("Bloc number\tStarting address\tEnding address\t\tUsed\tReference\tBlock size\n\n");

	current_element = blocks->first;
	while (current_element != NULL)
	{
		printf("     %d\t\t", number);
		printf("%p   --->   ", ((Block*)current_element->value)->first_word);
		printf("%p\t\t", ((Block*)current_element->value)->first_word + ((Block*)current_element->value)->size - 1);
		printf("%s\t", (((Block*)current_element->value)->used)?"Yes":"No");
		if (((Block*)current_element->value)->reference != NULL)
		{
			printf("%p\t", ((Block*)current_element->value)->reference);
		}
		else
		{
			printf("NULL\t\t");
		}
		printf("%ld\n", ((Block*)current_element->value)->size);

		current_element = current_element->next;
		number++;
	}

	printf("\nBloc number\tStarting address\tEnding address\t\tUsed\tReference\tBlock size\n\n");
}